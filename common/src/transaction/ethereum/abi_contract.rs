#![cfg(feature = "abi-contract")]

use crate::EthError;
use ethers::prelude::abi::{Contract, Token};
use ethers::prelude::{Address, H160, U256};
use serde::{Deserialize, Serialize};
use std::str::FromStr;

/// Ethereum ABI Contract
pub struct EthAbiContract {
    contract: Contract,
}

impl EthAbiContract {
    /// Create an instance via a string of ABI contract
    /// (generated by OpenZeppelin).
    pub fn new(abi_contract: &str) -> Result<Self, EthError> {
        Ok(Self {
            contract: Contract::load(abi_contract.as_bytes())?,
        })
    }

    /// Encode input data of specified function and arguments. The encoded data
    /// should be set to field data of EthTxInfo when invoking function
    /// build_signed_eth_tx.
    pub fn encode(
        &self,
        function_name: &str,
        tokens: Vec<EthAbiToken>,
    ) -> Result<Vec<u8>, EthError> {
        let function = self.contract.function(function_name)?;
        let tokens: Vec<Token> = tokens.into_iter().map(Into::into).collect();
        function.encode_input(&tokens).map_err(Into::into)
    }
}

/// Ethereum ABI token
#[derive(Serialize, Deserialize)]
pub enum EthAbiToken {
    Address(H160),
    FixedBytes(Vec<u8>),
    Bytes(Vec<u8>),
    Int(U256),
    Uint(U256),
    Bool(bool),
    String(String),
    FixedArray(Vec<EthAbiToken>),
    Array(Vec<EthAbiToken>),
    Tuple(Vec<EthAbiToken>),
}

impl EthAbiToken {
    /// Create from a string of address.
    pub fn from_address_str(address_str: &str) -> Result<Self, EthError> {
        Ok(Self::Address(
            Address::from_str(address_str).map_err(|_| EthError::HexConversion)?,
        ))
    }

    /// Create from a string of signed integer.
    pub fn from_int_str(int_str: &str) -> Result<Self, EthError> {
        Ok(Self::Int(
            U256::from_str(int_str).map_err(|_| EthError::HexConversion)?,
        ))
    }

    /// Create from a string of unsigned integer.
    pub fn from_uint_str(uint_str: &str) -> Result<Self, EthError> {
        Ok(Self::Uint(
            U256::from_str(uint_str).map_err(|_| EthError::HexConversion)?,
        ))
    }
}

impl From<EthAbiToken> for Token {
    fn from(eth_abi_token: EthAbiToken) -> Self {
        match eth_abi_token {
            EthAbiToken::Address(value) => Token::Address(value),
            EthAbiToken::FixedBytes(value) => Token::FixedBytes(value),
            EthAbiToken::Bytes(value) => Token::Bytes(value),
            EthAbiToken::Int(value) => Token::Int(value),
            EthAbiToken::Uint(value) => Token::Uint(value),
            EthAbiToken::Bool(value) => Token::Bool(value),
            EthAbiToken::String(value) => Token::String(value),
            EthAbiToken::FixedArray(values) => {
                Token::FixedArray(values.into_iter().map(Into::into).collect())
            }
            EthAbiToken::Array(values) => {
                Token::FixedArray(values.into_iter().map(Into::into).collect())
            }
            EthAbiToken::Tuple(values) => {
                Token::Tuple(values.into_iter().map(Into::into).collect())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{build_signed_eth_tx, EthAmount, EthNetwork, EthTxInfo, SecretKey};
    use ethers::utils::hex;
    use std::path::PathBuf;
    use std::sync::Arc;

    #[test]
    fn abi_contract_loading_test() {
        // Read the content of an ABI contract file.
        let dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
        let mut contract_file_path = PathBuf::new();
        contract_file_path.push(dir);
        contract_file_path.push("src/contract/erc20-abi.json");
        let abi_contract_str = std::fs::read_to_string(contract_file_path).unwrap();

        // Load ABI contract and encode input data.
        let abi_contract = EthAbiContract::new(&abi_contract_str).unwrap();
        let tokens = vec![
            EthAbiToken::from_address_str("0x2c600e0a72b3ae39e9b27d2e310b180abe779368").unwrap(),
            EthAbiToken::from_uint_str("100").unwrap(),
        ];
        let encoded_data = abi_contract.encode("transfer", tokens).unwrap();
        assert_eq!(
            hex::encode(encoded_data.clone()),
            "a9059cbb0000000000000000000000002c600e0a72b3ae39e9b27d2e310b180abe7793680000000000000000000000000000000000000000000000000000000000000100"
        );

        // Verify signed transaction data.
        let secret_key = SecretKey::from_hex(
            "24e585759e492f5e810607c82c202476c22c5876b10247ebf8b2bb7f75dbed2e".to_owned(),
        )
        .unwrap();
        let tx_info = EthTxInfo {
            to_address: "0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d".to_owned(),
            amount: EthAmount::EthDecimal {
                amount: 1.to_string(),
            },
            nonce: 0.to_string(),
            gas_limit: 21_000.to_string(),
            gas_price: EthAmount::WeiDecimal {
                amount: 1_000.to_string(),
            },
            data: Some(encoded_data),
            legacy_tx: true,
        };

        let signed_tx_data = build_signed_eth_tx(
            tx_info,
            EthNetwork::Custom {
                chain_id: 0,
                legacy: true,
            },
            Arc::new(secret_key),
        )
        .unwrap();

        assert_eq!(
            hex::encode(signed_tx_data),
            "f8ae808203e8825208944592d8f8d7b001e72cb26a73e4fa1806a51ac79d880de0b6b3a7640000b844a9059cbb0000000000000000000000002c600e0a72b3ae39e9b27d2e310b180abe77936800000000000000000000000000000000000000000000000000000000000001001ca0d41a62e428616adaa67a8db1480b1230ccdfba46c0370f2366346db262448e7ca0463f17c645ea4d1cbe58e0ac137d85739f9488307e72cf4d94f7ca250ba60eb3"
        );
    }

    #[test]
    fn abi_contract_erc721_loading_test() {
        // Read the content of an ABI contract file.
        let dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
        let mut contract_file_path = PathBuf::new();
        contract_file_path.push(dir);
        contract_file_path.push("src/contract/erc721-abi.json");
        let abi_contract_str = std::fs::read_to_string(contract_file_path).unwrap();

        // Load ABI contract and encode input data.
        let abi_contract = EthAbiContract::new(&abi_contract_str).unwrap();
        let tokens = vec![
            EthAbiToken::from_address_str("0x2c600e0a72b3ae39e9b27d2e310b180abe779368").unwrap(),
            EthAbiToken::from_uint_str("100").unwrap(),
        ];
        let encoded_data = abi_contract.encode("approve", tokens).unwrap();
        assert_eq!(
            hex::encode(encoded_data.clone()),
            "095ea7b30000000000000000000000002c600e0a72b3ae39e9b27d2e310b180abe7793680000000000000000000000000000000000000000000000000000000000000100"
        );

        // Verify signed transaction data.
        let secret_key = SecretKey::from_hex(
            "24e585759e492f5e810607c82c202476c22c5876b10247ebf8b2bb7f75dbed2e".to_owned(),
        )
        .unwrap();
        let tx_info = EthTxInfo {
            to_address: "0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d".to_owned(),
            amount: EthAmount::EthDecimal {
                amount: 1.to_string(),
            },
            nonce: 0.to_string(),
            gas_limit: 21_000.to_string(),
            gas_price: EthAmount::WeiDecimal {
                amount: 1_000.to_string(),
            },
            data: Some(encoded_data),
            legacy_tx: true,
        };

        let signed_tx_data = build_signed_eth_tx(
            tx_info,
            EthNetwork::Custom {
                chain_id: 0,
                legacy: true,
            },
            Arc::new(secret_key),
        )
        .unwrap();

        assert_eq!(
            hex::encode(signed_tx_data),
            "f8ae808203e8825208944592d8f8d7b001e72cb26a73e4fa1806a51ac79d880de0b6b3a7640000b844095ea7b30000000000000000000000002c600e0a72b3ae39e9b27d2e310b180abe77936800000000000000000000000000000000000000000000000000000000000001001ca00eef3b99bfb137fd93d63c98066e5e23e7d66924680a367cfb28fcb991468006a057d2012b639d885ab15854424fd7fd112a75eeab7800ed1e92fa723f67172c70"
        );
    }

    #[test]
    fn abi_contract_erc1155_loading_test() {
        // Read the content of an ABI contract file.
        let dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
        let mut contract_file_path = PathBuf::new();
        contract_file_path.push(dir);
        contract_file_path.push("src/contract/erc1155-abi.json");
        let abi_contract_str = std::fs::read_to_string(contract_file_path).unwrap();

        // Load ABI contract and encode input data.
        let abi_contract = EthAbiContract::new(&abi_contract_str).unwrap();
        let tokens = vec![
            EthAbiToken::from_address_str("0x2c600e0a72b3ae39e9b27d2e310b180abe779368").unwrap(),
            EthAbiToken::Bool(true),
        ];
        let encoded_data = abi_contract.encode("setApprovalForAll", tokens).unwrap();
        assert_eq!(
            hex::encode(encoded_data.clone()),
            "a22cb4650000000000000000000000002c600e0a72b3ae39e9b27d2e310b180abe7793680000000000000000000000000000000000000000000000000000000000000001"
        );

        // Verify signed transaction data.
        let secret_key = SecretKey::from_hex(
            "24e585759e492f5e810607c82c202476c22c5876b10247ebf8b2bb7f75dbed2e".to_owned(),
        )
        .unwrap();
        let tx_info = EthTxInfo {
            to_address: "0x4592d8f8d7b001e72cb26a73e4fa1806a51ac79d".to_owned(),
            amount: EthAmount::EthDecimal {
                amount: 1.to_string(),
            },
            nonce: 0.to_string(),
            gas_limit: 21_000.to_string(),
            gas_price: EthAmount::WeiDecimal {
                amount: 1_000.to_string(),
            },
            data: Some(encoded_data),
            legacy_tx: true,
        };

        let signed_tx_data = build_signed_eth_tx(
            tx_info,
            EthNetwork::Custom {
                chain_id: 0,
                legacy: true,
            },
            Arc::new(secret_key),
        )
        .unwrap();
        assert_eq!(
            hex::encode(signed_tx_data),
            "f8ae808203e8825208944592d8f8d7b001e72cb26a73e4fa1806a51ac79d880de0b6b3a7640000b844a22cb4650000000000000000000000002c600e0a72b3ae39e9b27d2e310b180abe77936800000000000000000000000000000000000000000000000000000000000000011ca06ddaa6cffb52c59ce0cf2f9bf4327b5d2d10d250d12fdabc34d41386f25a8372a0216560fefb1f3bc1463b106bef2ea0008f9c6e1b3d566d32e65994ababb3d220"
        );
    }
}
